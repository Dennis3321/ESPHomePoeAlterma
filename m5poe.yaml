esphome:
  name: m5poe
  friendly_name: m5poe

esp32:
  board: m5stack-core-esp32
  framework:
    type: arduino

logger:
  baud_rate: 0
api:
  encryption:
        key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password


ethernet:
  type: IP101
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk:
    pin: GPIO0
    mode: CLK_EXT_IN
  phy_addr: 1
  power_pin: GPIO5

uart:
  id: daikin_uart
  rx_pin: GPIO3
  tx_pin: GPIO1
  baud_rate: 9600
  parity: EVEN
  stop_bits: 1
  #debug:
  #  direction: BOTH
  #  dummy_receiver: true
  #  after:
  #    bytes: 16

external_components:
  - source:
      type: git
      url: https://github.com/Dennis3321/ESPHomePoeAlterma
      ref: main
      #ref: 53ea718d957c9cd3fc104be6f3e5ebd900f13192
      path: components
    components: [ daikin_x10a ]
    refresh: 0s  # DEVELOPMENT: Always fetch latest from GitHub


# Unit-4Relay uses I2C + external component (M5Stack)
  - source: github://m5stack/esphome-yaml/components@main
    components: unit4relay
    refresh: 5min


# PoESP32: I2C uses GPIO16/17 
i2c:
  sda: GPIO16
  scl: GPIO17
  scan: true

unit4relay:

# Interne relais (mag je ook hide-en in HA)
switch:
  - platform: unit4relay
    relay_1:
      id: r1
      internal: true
      restore_mode: RESTORE_DEFAULT_OFF
    relay_2:
      id: r2
      internal: true
      restore_mode: RESTORE_DEFAULT_OFF
    relay_3:
      id: r3
      internal: true
      restore_mode: RESTORE_DEFAULT_OFF
    relay_4:
      id: r4
      internal: true
      restore_mode: RESTORE_DEFAULT_OFF

select:
  - platform: template
    name: "Heatpump mode"
    id: hp_mode
    optimistic: true
    options:
      - "Off"
      - "Cooling"
      - "Heating"
    initial_option: "Off"
    set_action:
      - lambda: |-
          // Eerst veilig alles uit
          id(r1).turn_off();
          id(r2).turn_off();

          if (x == "Off") {
            // r1=0 r2=0
          } else if (x == "Cooling") {
            id(r1).turn_on();   // r1=1 r2=0
          } else if (x == "Heating") {
            id(r2).turn_on();   // r1=0 r2=1
          }

  - platform: template
    name: "Heatpump smartgrid"
    id: hp_sg
    optimistic: true
    options:
      - "Free running"
      - "Forced off"
      - "Recommended on"
      - "Forced on"
    initial_option: "Free running"
    set_action:
      - lambda: |-
          // Eerst veilig alles uit
          id(r3).turn_off();
          id(r4).turn_off();

          if (x == "Free running") {
            // r3=0 r4=0
          } else if (x == "Forced off") {
            id(r4).turn_on();   // r3=0 r4=1
          } else if (x == "Recommended on") {
            id(r3).turn_on();   // r3=1 r4=0
          } else if (x == "Forced on") {
            id(r3).turn_on();   // r3=1 r4=1
            id(r4).turn_on();
          }


daikin_x10a:
  id: daikin_comp
  uart_id: daikin_uart

sensor:
  - platform: template
    name: "Leaving water temp. before BUH"
    id: r1t_sensor
    unit_of_measurement: "°C"
    device_class: temperature
    lambda: |-
      std::string val = id(daikin_comp).get_register_value("Leaving water temp. before BUH (R1T)");
      if (val.empty()) return NAN;
      return atof(val.c_str());

  - platform: template
    name: "Leaving water temp. after BUH"
    id: r2t_sensor
    unit_of_measurement: "°C"
    device_class: temperature
    lambda: |-
      std::string val = id(daikin_comp).get_register_value("Leaving water temp. after BUH (R2T)");
      if (val.empty()) return NAN;
      return atof(val.c_str());

  - platform: template
    name: "Refrig. Temp. liquid side"
    id: r3t_sensor
    unit_of_measurement: "°C"
    device_class: temperature
    lambda: |-
      std::string val = id(daikin_comp).get_register_value("Refrig. Temp. liquid side (R3T)");
      if (val.empty()) return NAN;
      return atof(val.c_str());

  - platform: template
    name: "Inlet water temp."
    id: r4t_sensor
    unit_of_measurement: "°C"
    device_class: temperature
    lambda: |-
      std::string val = id(daikin_comp).get_register_value("Inlet water temp.(R4T)");
      if (val.empty()) return NAN;
      return atof(val.c_str());

  - platform: template
    name: "DHW tank temp."
    id: r5t_sensor
    unit_of_measurement: "°C"
    device_class: temperature
    lambda: |-
      std::string val = id(daikin_comp).get_register_value("DHW tank temp. (R5T)");
      if (val.empty()) return NAN;
      return atof(val.c_str());

  - platform: template
    name: "Indoor ambient temp."
    id: indoor_temp_sensor
    unit_of_measurement: "°C"
    device_class: temperature
    lambda: |-
      std::string val = id(daikin_comp).get_register_value("Indoor ambient temp. (R1T)");
      if (val.empty()) return NAN;
      return atof(val.c_str());

  - platform: template
    name: "Ext. indoor ambient sensor"
    id: r6t_sensor
    unit_of_measurement: "°C"
    device_class: temperature
    lambda: |-
      std::string val = id(daikin_comp).get_register_value("Ext. indoor ambient sensor (R6T)");
      if (val.empty()) return NAN;
      return atof(val.c_str());